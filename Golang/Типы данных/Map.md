>> является частью [[Типы данных|типов данных Golang]]

Мапа это `ассоциативный контейнер, основанный на хеш-таблице`

### Основные сведения
------
1. **key-value** хранилище, доступ к **значениям** осуществляется по **ключу**
2. **key** должен быть comparable, то есть поддерживать операцию сравнения
3. основана на [[Map#Hash-Таблица|hash-таблице]]
4. по мере заполнении возможна [[#Эвакуация данных|эвакуация данных]]
5. порядок обхода map'ы всегда случайный, так как, например, после эвакуации данных, порядок bucket'ов в hash-таблице может измениться, и, чтобы программисты на Golang не привязывались к порядку элементов в map'е, разработчики языка нарочно добавили в обход map'ы рандом
6. fmt.Println сортирует map'у перед выводом на экран (для удобства восприятия текстового представления map'ы, наверное)
7. нулевое значение (значение по умолчанию) равно nil
8. нельзя взять указатель на какое-нибудь value из map, так как при эвакуации value переедет в новый bucket, и, как следствие, в новое место в памяти, и взятый ранее указатель может стать невалидным

### Эвакуация данных
------
1. Вызывается, когда bucket'ы заполнены в среднем больше, чем на 80% -> в таком случае количество bucket'ов увеличивается в два раза
2. Старые bucket'ы удаляются, создаются новые bucket'ы с переиндексацией
3. Эвакуация необходима для избежания создания слишком длинных линковок bucket'ов, следствием чего является повышение сложности операций в hash-таблице до O(n)
4. Для избежания эвакуации данных можно заранее аллоцировать память для мапы на N элементов

### Hash-Таблица
----------
##### Основные сведения
- hash-таблица представляет собой массив бакетов
	- бакет -- "коробка" с несколькими записями key =\> value
	- [[Map#схематичное представление|схематичное представление]]
- доступные операции:
	1. map\[key] = value ([[Map#операция вставки|операция вставки]])
	2. value, ok := map\[key] ([[Map#операция поиска|операция поиска]])
	3. delete(map, key) ([[Map#операция удаления|операция удаления]])
- скорость выполнения операций константна O(1)
- для операций используется hash-функция

##### схематичное представление
![[hash_table.png]]

##### операция вставки
1. при вставке значения по ключу, создаётся новый bucket, либо используется существующий bucket из массива bucket'ов
2. этот созданный/существующий bucket имеет индекс в общем массиве bucket'ов, посчитанный из hash-функции
3. если в этом bucket'е не найдена запись с добавляемым ключом,  то добавляется новая запись, содержащая добавляемые ключ и значение
4. если в этом bucket'е уже существует запись с добавляемым ключом, то эта запись заменяется новой записью с новым value

таким образом производится вставка новых значений по ключу в hash-таблицу при помощи hash-функции
```
func InsertValueByKey(key, value) {
	bucketIndex := HashFunc(key)
	if !map.buckets.exists(bucketIndex) {
		map.buckets[bucketIndex] = new(Bucket)
	}
	
	if !map.buckets[bucketIndex].exists(entry) {
		map.buckets[bucketIndex] += entry(key, value)
	} else {
		map.buckets[bucketIndex].entry = entry(key, value)
	}
}
```
bucket вмещает в себя до 8-ми entry. В случае переполнения, к переполненному bucket'у линкуется вновь созданный bucket, тем самым одному bucket индексу уже будет соответствовать списов bucket'ов

##### операция поиска
1. при поиске значения по ключу, по hash-функции получается индекс bucket'а, в котором может лежать искомое значение
2. если bucket с соответствующим индексом не существует, то значение не найдено
3. если bucket с соответствующим индексом найден, то прогоняется цикл по всем записям в bucket'е, и при совпадении ключа возвращается найденное значение
4. если в найденном bucket'е записей с искомым ключом не найдено, то значение не найдено

таким образом производится поиск значений по ключу в hash-таблице при помощи hash-функции
```
func GetValueByKey(key) Value {
	bucketIndex := HashFunc(key)
	if !map.buckets.exists(bucketIndex) {
		return nil
	}

	bucket := map.buckets[bucketIndex]
	for _, entry := range bucket {
		if entry.key == key {
			return entry.value
		}
	}

	return nil
}
```

##### операция удаления
аналогично [[Map#операция поиска|операция поиска]] операции поиска, ищется запись по ключу, после чего происходит удаление найденной записи из соответствующего bucket'а
```
for DeleteValueByKey(key) {
	bucketIndex := HashFunc(key)
	if !map.buckets.exists(bucketIndex) {
		return
	}

	bucket := map.buckets[bucketIndex]
	for _, entry := range bucket {
		if entry.key == key {
			map.buckets[bucketIndex] -= entry(key, value)
		}
	}
}
```
