>> является частью [[Конкурентность|конкурентности Golang'а]]

### Основные сведения
---
1. могут быть
	- небуферезированные `make(chan int)`
	- буферезированные `make(chan int, 4)`
2. используются для
	-  передачи данных между горутинами  (из stack'а одной goroutine'ы в stack другой)
		1. в случае буфферизированного канала
			1. сообщение будет из стека отправителя положено в буфер (1-е копирование)
			2. после чего из буфера положено в стек читателя (2-е копирование)
		2. в случае небуфферезированное канала
			1. сообщение будет передано напрямую из стека отправителя в стек читателя (просто передачей указателя, даже не будет производиться копирование)
	- блокировки и синхронизации горутин
3. потокобезопасны
4. буферезированные каналы получают и отдают элементы согласно FIFO
5. при попытке добавить элемент в заполненный буфер, channel блокирует исполнение goroutine'ы на этой самой попытке до тех пор, пока в буфере не будет освобождено место для нового добавляемого элемента, то есть пока другая goroutine'а не вычитает хотя бы один элемент из этого channel'а
6. в случае, если goroutine'а блокируется на записи в channel, и при этом никто не читает из этого channel'а, то случается явление, называемое deadlock -- goroutine'а навечно блокируется на попытке записи в канал
7. при попытке прочитать элемент из пустого буфера, channel блокирует исполнение goroutine'ы на этой самой попытке до тех пор, пока другой goroutine'ой в буфер этого channel не будет записан хотя бы один элемент
8. в случае, если goroutine'а блокируется на чтении из channel'а, и при этом никто не пишет в этот channel, то случиться deadlock -- goroutine'а навечно блокируется на попытке прочитать значение из канала

### Структура Channel
---
###### Состоит из нескольких элементов, например:
1. qcount -> размер буфера channel'а
2. closed -> флаг, указывающий на то, закрыт ли канал
3. lock -> mutex, позволяющий обеспечить потокобезопасноть при одновременной работе нескольких goroutine'н с одним каналом
4. buffer -> буффер канала, представляет из себя кольцевую очередь

### Операция Select
---
```
select {
case val_a := <-channel_a:
	handler_a(val_a)
case val_b := <-channel_b:
	handler_b(val_b)
default:
	handler_default()
}
```
##### Принцип работы
1. при отсутствии секции `default` исполнение goroutine'ы блокируется на конструкции `select` до момента, пока хотя бы в один из channel'ов не будет доставлено значение, после чего будет вызвана секция для соответствующего channel'а
2. если некоторые значения одновременно будут доставлены в два и более channel'а, то выбор секции будет осуществляться случайным образом
3. при наличии секции `default` при достижении goroutine'ой конструкции `select` возможно два варианта:
	- в случае, если в каком-нибудь channel'е уже лежит доставленное значение, то будет выполнена соответствующая секция (если таких channel'ов несколько, то секция будет выбрана случайным образом)
	- в случае, если ни в одном из channel'ов не лежит никаких значений, то будет выполнена секция `default`

### Закрытие канала
---
`close(channel)`
Принцип работы
1. в случае, если channel не был инициализирован `make(chan type)`, то будет вызвана panic'а
2. в случае, если channel был инициализирован и уже был закрыт, то быдет вызвана panic'а
3. в случае, если channel был инициализирован и ещё не был закрыт, то
	- флаг `closed` устанавливается в `true`
	- все заблокированные на чтении в этот channel goroutine'ы будут разблокированы, получив значение по умолчанию из channel'а и опциональный параметр `ok`, сигнализирующий о том, было ли получено доставленное другой goroutine'ой значение, или же было получено значение по умолчанию из-за закрытия канала
	- все записи в закрытый канал будут приводить к panic'е
4. хорошей практикой является закрытие channel'а той goroutine'ой, которая в него пишет
