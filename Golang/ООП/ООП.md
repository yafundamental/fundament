Related: [[Golang]]

### Основные сведения
---
1. Классы -> Структуры
2. Методы классов -> Функции структур
3. [[#Наследование]] -> [[#Встраивание в Golang|Встраивание]]
4. [[#Полиморфизм]] -> [[#Инкапсуляция в Golang|Интерфейс]]
5. [[#Инкапсуляция]]
6. Абстракция

### Наследование
---
- наследование в программировании — концепция, согласно которой некоторый тип данных может наследовать данные и функциональность другого, уже существующего типа, способствуя переиспользованию уже написанных компонентов программного обеспечения

##### Наследование в Golang
В Golang переиспользование уже написанных компонентов ПО достигается при помощи встраивания
##### Встраивание в Golang
![[embedding.png]]

### Полиморфизм
---
- полиморфизм в программировании — это понятие, которое позволяет разным сущностям, удовлетворяющим определённому контраку, выполнять одни и те же действия и применяться в одних и тех же уловиям, при этом неважно, как эти сущности устроены внутри -- главное, чтобы был соблюдён контракт
##### Полиморфизм в Golang
В Golang полиморфизм реализован при помощи интерфейсов
##### Interface в Golang
- interface определяет контракт для сущностей, которые могут быть использованы в один и тех же условиях
- interface определяет набор методов, которые должны быть реализованы у структуры для того, чтобы структура "удовлетворяла интерфейсы"
- в Golang нигде не указывается явное соответствие сущностей интерфейсам, так называемый DuckTyping, если структура имеет все методы, определяемые interface'ом, то эта структура автоматически удовлетвораяет этому interface'у
- благодаря interface'ам мы можем создавать mock'и при unit-тестировании
- существует "пустой" interface `interface{}`, ему соответствуют все объекты Golang
- примеры популярных стандартных interface'ов
	1. io.Reader `r.Read(to-buff)`
	2. io.Writer `w.Write(from-buff)`
	3. error `Error() string`
- интерфейсы можно приводить в конкретным типам при помощи type assertions
```
func main() {
	var s string = "hello"
	var i interface{} = s

	s := i.(string)
	fmt.Println(s)      // hello

	s, ok := i.(string)
	fmt.Println(s, ok)  // hello true

	f, ok := i.(float64)
	fmt.Println(f, ok)  // 0     false

	f = i.(float64)     // panic
	fmt.Println(f)
}
```
- interface равен nil только когда его type и его value равны nil, то есть если у interface'а тип уже определён, то этот interface не будет равен nil
```
1. func main() {
2. 	 var a *os.PathError
3. 	 var b error = a
4.
5.	 fmt.Println(b)        // <nil>
6. 	 fmt.Println(b == nil) // false
7. }
```
в данном примере мы определили interface'у тип в 3-й строке, поэтому этот interface уже !nil

### Инкапсуляция
---
- инкапсуляция в программировании — это принцип, согласно которому внутреннее устройство сущностей нужно скрывать в специальной «оболочке» и защищать от вмешательств извне
- доступ к функциональности сущности возможен через специальные открытые методы, предоставляющие интерфейс для взаимодействия, скрывающие детали реализации
##### Инкапсуляция в Golang
В Golang инкапсуляция реализована при помощи пакетов и регистра первой буквы в названии сущности
- если первая буква структуры/функции/глобальной переменной написана в верхнем регистре, то такая сущность будет доступна из других пакетов
- если первыа бука написана в нижнем регистре, то такая сущность будет доступна только в рамках её пакета
